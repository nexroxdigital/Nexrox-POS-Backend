import mongoose from "mongoose";

import customerModel from "../customer/customer.model.js";
import incomeModel from "../income/income.model.js";
import inventoryLotsModel from "../inventoryLots/inventoryLots.model.js";
import Sale from "./sale.model.js";
import customerCrateHistoryModel from "../customerCrateHistory/customerCrateHistory.model.js";

// @desc Create sale a sale list + Update customer collection  ( caret info + due + balance ) Update inventory lots ( total sold + total sold kg + lotCommission + customerCommission ) + Create Income document
// @access  Admin
export const createSale = async (saleData) => {
  const session = await mongoose.startSession();
  session.startTransaction();

  try {
    // 1. Create the sale
    const [sale] = await Sale.create([saleData], { session });

    // 2. Get customer data
    const customer = await customerModel
      .findById(saleData.customerId)
      .session(session);

    if (!customer) {
      throw new Error("Customer not found");
    }

    // 3. Calculate total crates used in this sale
    let totalCrateType1 = 0;
    let totalCrateType2 = 0;

    saleData.items.forEach((item) => {
      item.selected_lots.forEach((lot) => {
        totalCrateType1 += lot.crate_type1 || 0;
        totalCrateType2 += lot.crate_type2 || 0;
      });
    });

    // 4. Update customer data
    const updates = {};

    // Update balance (deduct received_amount_from_balance)
    // const receivedFromBalance =
    //   saleData.payment_details.received_amount_from_balance || 0;
    // updates["account_info.balance"] =
    //   customer.account_info.balance - receivedFromBalance;

    // Update due (add due_amount)
    const dueAmount = saleData.payment_details.due_amount || 0;
    updates["account_info.due"] = customer.account_info.due + dueAmount;

    // Update crates (subtract used crates, minimum 0)
    const newCrateType1 = customer.crate_info.type_1 + totalCrateType1;
    const newCrateType2 = customer.crate_info.type_2 + totalCrateType2;

    updates["crate_info.type_1"] = Math.max(0, newCrateType1);
    updates["crate_info.type_2"] = Math.max(0, newCrateType2);

    // 5. Apply updates to customer
    await customerModel.findByIdAndUpdate(
      saleData.customerId,
      { $set: updates },
      { session, new: true }
    );

    let lotIds = [];
    // 6. Update inventory lots
    for (const item of saleData.items) {
      for (const lot of item.selected_lots) {
        lotIds.push(lot.lotId);
        // Get current lot data
        const inventoryLot = await inventoryLotsModel
          .findById(lot.lotId)
          .session(session);

        if (!inventoryLot) {
          throw new Error(`InventoryLot not found: ${lot.lotId}`);
        }

        let newStatus;
        // for check box quantity and update status
        if (lot.box_quantity > 0) {
          if (inventoryLot.remaining_boxes < lot.box_quantity) {
            throw new Error(`Not enough boxes in lot: ${lot.lot_name}`);
          }

          newStatus =
            inventoryLot.remaining_boxes - lot.box_quantity === 0
              ? "stock out"
              : "in stock";
        }

        // for check carat quantity and update status
        if (lot.carat_type1 > 0 || lot.carat_type2 > 0) {
          if (inventoryLot.remaining_carat_Type_1 < lot.carat_type1) {
            throw new Error(`Not enough carat in lot: ${lot.lot_name}`);
          }

          if (inventoryLot.remaining_carat_Type_2 < lot.carat_type2) {
            throw new Error(`Not enough carat in lot: ${lot.lot_name}`);
          }

          newStatus =
            inventoryLot.remaining_carat_Type_1 - lot.carat_type1 === 0 &&
            inventoryLot.remaining_carat_Type_2 - lot.carat_type2 === 0
              ? "stock out"
              : "in stock";
        }

        // Calculate increments for this lot
        const kgSold = lot.kg || 0;
        const soldPrice = lot.selling_price || 0;
        const lotCommission = lot.lot_commission_amount || 0;
        const customerCommission = item.customer_commission_amount || 0;

        // Prepare lot updates
        const lotUpdates = {
          // Increment sales
          "sales.totalKgSold": inventoryLot.sales.totalKgSold + kgSold,
          "sales.totalSoldPrice": inventoryLot.sales.totalSoldPrice + soldPrice,

          // Increment profits
          "profits.lotProfit": inventoryLot.profits.lotProfit + lotCommission,
          "profits.customerProfit":
            inventoryLot.profits.customerProfit + customerCommission,
          "profits.totalProfit":
            inventoryLot.profits.totalProfit +
            lotCommission +
            customerCommission,
          remaining_boxes: inventoryLot.remaining_boxes - lot.box_quantity,

          "carat.remaining_carat_Type_1":
            inventoryLot.remaining_carat_Type_1 - lot.carat_type1,
          "carat.remaining_carat_Type_2":
            inventoryLot.remaining_carat_Type_2 - lot.carat_type2,

          status: newStatus,
        };

        // Apply updates to inventory lot
        await inventoryLotsModel.findByIdAndUpdate(
          lot.lotId,
          { $set: lotUpdates },
          { session, new: true }
        );
      }
    }

    // 7. Create Income document
    const incomeData = {
      sellDate: new Date(saleData.sale_date),
      information: {
        saleId: sale._id.toString(),
        lots_Ids: lotIds,
      },
      total_Sell: saleData.payment_details.payable_amount,
      lot_Commission: saleData.total_lots_commission,
      customer_Commission: saleData.total_custom_commission,

      total_Income: saleData.total_profit,

      received_amount: saleData.payment_details.received_amount || 0,
      // received_amount_from_balance:
      //   saleData.payment_details.received_amount_from_balance || 0,
      due: saleData.payment_details.due_amount || 0,
    };

    await incomeModel.create([incomeData], { session });

    // 8. Create Customer Crate History if crates used
    if (totalCrateType1 > 0 || totalCrateType2 > 0) {
      const crateHistoryData = {
        saleId: sale._id,
        customerId: saleData.customerId,
        crate_type1: totalCrateType1,
        crate_type2: totalCrateType2,
        crate_type1_price:
          saleData.payment_details?.extra_crate_type1_price || 0,
        crate_type2_price:
          saleData.payment_details?.extra_crate_type2_price || 0,
      };

      await customerCrateHistoryModel.create([crateHistoryData], { session });
    }

    // 9. Commit transaction
    await session.commitTransaction();
    session.endSession();

    return sale;
  } catch (error) {
    await session.abortTransaction();
    session.endSession();
    throw error;
  }
};

// @desc    Get all sales
// @access  Admin
export const getAllSales = async (search, page, limit) => {
  const skip = (page - 1) * limit;

  let pipeline = [];

  if (search) {
    // Pipeline with search
    pipeline = [
      // Step 1: Unwind items array
      { $unwind: "$items" },

      // Step 2: Unwind selected_lots array
      { $unwind: "$items.selected_lots" },

      // Step 3: Lookup lot details for matching
      {
        $lookup: {
          from: "inventorylots", // Make sure this matches your collection name
          localField: "items.selected_lots.lotId",
          foreignField: "_id",
          as: "lotInfo",
        },
      },

      // Step 4: Unwind lotInfo
      { $unwind: { path: "$lotInfo", preserveNullAndEmptyArrays: true } },

      // Step 5: Match the lot_name (case-insensitive search)
      {
        $match: {
          "lotInfo.lot_name": {
            $regex: search,
            $options: "i",
          },
        },
      },

      // Step 6: Sort by createdAt
      { $sort: { createdAt: -1 } },
    ];
  } else {
    // Pipeline without search
    pipeline = [{ $sort: { createdAt: -1 } }];
  }

  // Count total documents
  const countPipeline = [...pipeline, { $count: "total" }];
  const countResult = await Sale.aggregate(countPipeline);
  const total = countResult.length > 0 ? countResult[0].total : 0;

  // Add pagination
  pipeline.push({ $skip: skip }, { $limit: limit });

  // Execute aggregation
  let sales = await Sale.aggregate(pipeline);

  // Populate references
  sales = await Sale.populate(sales, [
    {
      path: "customerId",
      select: "basic_info.name contact_info.phone contact_info.email",
    },
    {
      path: "items.productId",
      select: "productName basePrice categoryId",
      populate: {
        path: "categoryId",
        select: "categoryName",
      },
    },
    {
      path: "items.selected_lots.lotId",
      select: "lot_name commissionRate",
    },
  ]);

  return {
    total,
    page,
    limit,
    totalPages: Math.ceil(total / limit),
    sales,
  };
};

// @desc    Get all sales by customer with search and pagination
// @access  Admin
// @desc    Get all sales by customer with search and pagination
// @access  Admin
export const getAllSalesByCustomer = async (
  customerId,
  page,
  limit,
  filters = {}
) => {
  const skip = (page - 1) * limit;

  const aggregationPipeline = [
    // Stage 1: Match sales by customer
    {
      $match: {
        customerId: new mongoose.Types.ObjectId(customerId),
      },
    },
    // Stage 2: Unwind items to search within them
    {
      $unwind: "$items",
    },
    // Stage 3: Lookup product details with search filter
    {
      $lookup: {
        from: "products",
        localField: "items.productId",
        foreignField: "_id",
        as: "productData",
        pipeline: [
          // Apply product search filter here
          ...(filters.search
            ? [
                {
                  $match: {
                    productName: { $regex: filters.search, $options: "i" },
                  },
                },
              ]
            : []),
          // Lookup category
          {
            $lookup: {
              from: "categories",
              localField: "categoryId",
              foreignField: "_id",
              as: "categoryData",
              pipeline: [
                {
                  $project: { categoryName: 1 },
                },
              ],
            },
          },
          {
            $unwind: {
              path: "$categoryData",
              preserveNullAndEmptyArrays: true,
            },
          },
          {
            $project: {
              productName: 1,
              basePrice: 1,
              categoryId: 1,
              categoryName: "$categoryData.categoryName",
            },
          },
        ],
      },
    },
    // Stage 4: Replace productId with the actual product data
    {
      $addFields: {
        "items.productId": { $arrayElemAt: ["$productData", 0] },
      },
    },
    // Stage 5: Lookup lot details
    {
      $lookup: {
        from: "inventorylots",
        localField: "items.selected_lots.lotId",
        foreignField: "_id",
        as: "lotData",
        pipeline: [
          {
            $project: { lot_name: 1, commissionRate: 1 },
          },
        ],
      },
    },
    // Stage 6: Replace lotId with actual lot data in selected_lots
    {
      $addFields: {
        "items.selected_lots": {
          $map: {
            input: "$items.selected_lots",
            as: "lot",
            in: {
              $mergeObjects: [
                "$$lot",
                {
                  lotId: {
                    $arrayElemAt: [
                      {
                        $filter: {
                          input: "$lotData",
                          as: "ld",
                          cond: { $eq: ["$$ld._id", "$$lot.lotId"] },
                        },
                      },
                      0,
                    ],
                  },
                },
              ],
            },
          },
        },
      },
    },
    // Stage 7: Filter out items with empty products (ONLY if search is applied)
    ...(filters.search
      ? [
          {
            $match: {
              "items.productId": { $ne: null }, // Product exists after filtering
            },
          },
        ]
      : []),
    // Stage 8: Lookup customer details
    {
      $lookup: {
        from: "customers",
        localField: "customerId",
        foreignField: "_id",
        as: "customerData",
        pipeline: [
          {
            $project: {
              "basic_info.name": 1,
              "contact_info.phone": 1,
              "contact_info.email": 1,
            },
          },
        ],
      },
    },
    {
      $addFields: {
        customerId: { $arrayElemAt: ["$customerData", 0] },
      },
    },
    // Stage 9: Remove temporary fields
    {
      $project: {
        productData: 0,
        lotData: 0,
        customerData: 0,
      },
    },
    // Stage 10: Group back by sale
    {
      $group: {
        _id: "$_id",
        createdAt: { $first: "$createdAt" },
        updatedAt: { $first: "$updatedAt" },
        sale_date: { $first: "$sale_date" },
        customerId: { $first: "$customerId" },
        total_custom_commission: { $first: "$total_custom_commission" },
        total_lots_commission: { $first: "$total_lots_commission" },
        total_profit: { $first: "$total_profit" },
        payment_details: { $first: "$payment_details" },
        items: { $push: "$items" },
      },
    },
    // Stage 11: Filter out sales with empty items (if search applied)
    ...(filters.search
      ? [
          {
            $match: {
              "items.0": { $exists: true }, // At least one item exists
            },
          },
        ]
      : []),
    // Stage 12: Sort
    { $sort: { createdAt: -1 } },
  ];

  // Execute aggregation for data
  const sales = await Sale.aggregate([
    ...aggregationPipeline,
    { $skip: skip },
    { $limit: limit },
  ]);

  // Execute aggregation for total count
  const totalResult = await Sale.aggregate([
    ...aggregationPipeline,
    { $count: "total" },
  ]);

  const total = totalResult[0]?.total || 0;

  return {
    total,
    page,
    limit,
    totalPages: Math.ceil(total / limit),
    sales,
  };
};

// @desc    Get sale details by ID
// @access  Admin
export const getSaleById = async (id) => {
  const sale = await Sale.findById(id)
    .populate(
      "customerId",
      "basic_info.name contact_info.phone contact_info.email"
    )
    .populate({
      path: "items.productId",
      select: "productName basePrice categoryId",
      populate: {
        path: "categoryId",
        select: "categoryName",
      },
    })
    .populate("items.selected_lots.lotId", "lot_name commissionRate");

  return sale;
};

// @desc Get lot summary with sales list by lotId
// @access private
export const getLotSummaryService = async (lotId) => {
  const data = await Sale.aggregate([
    { $unwind: "$items" },
    { $unwind: "$items.selected_lots" },

    // @desc Filter by lotId from params
    {
      $match: {
        "items.selected_lots.lotId": new mongoose.Types.ObjectId(lotId),
      },
    },

    // @desc Join lot info
    {
      $lookup: {
        from: "inventorylots",
        localField: "items.selected_lots.lotId",
        foreignField: "_id",
        as: "lot",
      },
    },
    { $unwind: "$lot" },

    // @desc Join supplier info
    {
      $lookup: {
        from: "suppliers",
        localField: "lot.supplierId",
        foreignField: "_id",
        as: "supplier",
      },
    },
    { $unwind: "$supplier" },

    // @desc Project sale-level and lot-level fields
    {
      $project: {
        _id: 0,
        lot_name: "$lot.lot_name",
        supplier_name: "$supplier.basic_info.name",
        lot_expenses: "$lot.expenses",

        sale: {
          kg: "$items.selected_lots.kg",
          discount_Kg: "$items.selected_lots.discount_Kg",
          unit_price: "$items.selected_lots.unit_price",

          total_price: {
            $multiply: [
              {
                $subtract: [
                  "$items.selected_lots.kg",
                  "$items.selected_lots.discount_Kg",
                ],
              },
              "$items.selected_lots.unit_price",
            ],
          },

          total_crate: {
            $cond: [
              {
                $gt: [
                  {
                    $add: [
                      "$items.selected_lots.crate_type1",
                      "$items.selected_lots.crate_type2",
                    ],
                  },
                  0,
                ],
              },

              {
                $add: [
                  "$items.selected_lots.crate_type1",
                  "$items.selected_lots.crate_type2",
                ],
              },

              {
                $cond: [
                  { $gt: ["$items.selected_lots.box_quantity", 0] },
                  "$items.selected_lots.box_quantity",
                  0,
                ],
              },
            ],
          },
        },
      },
    },

    // @desc Group all sales under the same lot
    {
      $group: {
        _id: "$lot_name",
        lot_name: { $first: "$lot_name" },
        supplier_name: { $first: "$supplier_name" },
        lot_expenses: { $first: "$lot_expenses" },
        sales: { $push: "$sale" }, // all sale items under this lot
      },
    },

    { $project: { _id: 0 } }, // remove _id field
  ]);

  return data[0] || {}; // return the first (and only) lot object
};
